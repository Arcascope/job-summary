(()=>{"use strict";var __webpack_modules__={905:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval("\n// UNUSED EXPORTS: jobSummaryFilePath\n\n;// CONCATENATED MODULE: external \"child_process\"\nconst external_child_process_namespaceObject = require(\"child_process\");\n;// CONCATENATED MODULE: external \"fs\"\nconst external_fs_namespaceObject = require(\"fs\");\n;// CONCATENATED MODULE: external \"fs/promises\"\nconst promises_namespaceObject = require(\"fs/promises\");\n;// CONCATENATED MODULE: external \"path\"\nconst external_path_namespaceObject = require(\"path\");\nvar external_path_default = /*#__PURE__*/__webpack_require__.n(external_path_namespaceObject);\n;// CONCATENATED MODULE: ./src/index.ts\n\n\n\n\nconst SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';\nconst jobSummaryFilePath = async () => {\n    const pathFromEnv = process.env[SUMMARY_ENV_VAR];\n    if (!pathFromEnv) {\n        throw new Error(`Unable to find environment variable for $${SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);\n    }\n    try {\n        await (0,promises_namespaceObject.access)(pathFromEnv, promises_namespaceObject.constants.R_OK | promises_namespaceObject.constants.W_OK);\n    }\n    catch {\n        throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);\n    }\n    return pathFromEnv;\n};\nconst run = async () => {\n    let jobSummary = '';\n    const filePath = await jobSummaryFilePath();\n    const pathObj = external_path_default().parse(filePath);\n    const dir = pathObj.dir;\n    console.log(`Job summary file directory: ${dir}`);\n    const files = (0,external_fs_namespaceObject.readdirSync)(dir);\n    for (const file of files) {\n        const fileObj = external_path_default().parse(file);\n        if (fileObj.base.startsWith('step_summary_')) {\n            console.log(`Found step summary: ${file}`);\n            const stepSummary = (0,external_fs_namespaceObject.readFileSync)(`${dir}/${file}`, 'utf8');\n            jobSummary += stepSummary;\n        }\n    }\n    console.log(`Job summary: ${jobSummary}`);\n    (0,external_fs_namespaceObject.writeFileSync)('README.md', jobSummary);\n    (0,external_fs_namespaceObject.writeFileSync)('config.js', `// A marked renderer for mermaid diagrams\r\n  const renderer = {\r\n      code(code, infostring) {\r\n          if (infostring === 'mermaid'){\r\n              return \\`<pre class=\"mermaid\">\\$\\{code\\}</pre>\\`\r\n          }\r\n          return false\r\n      },\r\n  };\r\n  \r\n  module.exports = {\r\n      marked_extensions: [{ renderer }],\r\n      script: [\r\n          { url: 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js' },  \r\n          // Alternative to above: if you have no Internet access, you can also embed a local copy\r\n          // { content: require('fs').readFileSync('./node_modules/mermaid/dist/mermaid.js', 'utf-8') }\r\n          // For some reason, mermaid initialize doesn't render diagrams as it should. It's like it's missing\r\n          // the document.ready callback. Instead we can explicitly render the diagrams\r\n          { content: 'mermaid.initialize({ startOnLoad: false}); (async () => { await mermaid.run(); })();' }\r\n      ]\r\n  };`);\n    (0,external_child_process_namespaceObject.execSync)(`npm i -g md-to-pdf`);\n    (0,external_child_process_namespaceObject.execSync)(`md-to-pdf --config-file ./config.js ./README.md`);\n    console.log('PDF generated successfully');\n    (0,external_fs_namespaceObject.readdirSync)('.').forEach(file => {\n        if (file.endsWith('.pdf')) {\n            console.log(`PDF file: ${file}`);\n        }\n    });\n};\nrun();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA1LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNLHNDQUE0Qiw0Qjs7QUNBbEMsTUFBTSwyQkFBNEIsaUI7O0FDQWxDLE1BQU0sd0JBQTRCLDBCOztBQ0FsQyxNQUFNLDZCQUE0QixtQjs7O0FDQU87QUFDcUI7QUFDZDtBQUN4QjtBQUN4QjtBQUNPO0FBQ1A7QUFDQTtBQUNBLG9FQUFvRSxnQkFBZ0I7QUFDcEY7QUFDQTtBQUNBLGNBQWMsbUNBQU0sY0FBYyxrQ0FBUyxRQUFRLGtDQUFTO0FBQzVEO0FBQ0E7QUFDQSwyREFBMkQsWUFBWTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQVU7QUFDOUI7QUFDQSwrQ0FBK0MsSUFBSTtBQUNuRCxrQkFBa0IsMkNBQVc7QUFDN0I7QUFDQSx3QkFBd0IsNkJBQVU7QUFDbEM7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRCxnQ0FBZ0MsNENBQVksSUFBSSxJQUFJLEdBQUcsS0FBSztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQyxJQUFJLDZDQUFhO0FBQ2pCLElBQUksNkNBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBLFlBQVksaUVBQWlFO0FBQzdFO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZLCtCQUErQixtQkFBbUIsR0FBRyxlQUFlLHNCQUFzQixJQUFJO0FBQzFHO0FBQ0EsSUFBSTtBQUNKLElBQUksbURBQVE7QUFDWixJQUFJLG1EQUFRO0FBQ1o7QUFDQSxJQUFJLDJDQUFXO0FBQ2Y7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQztBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWN0aW9uLXR5cGVzY3JpcHQvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImNoaWxkX3Byb2Nlc3NcIj9mZmZmIiwid2VicGFjazovL2FjdGlvbi10eXBlc2NyaXB0L2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJmc1wiPzQzZjEiLCJ3ZWJwYWNrOi8vYWN0aW9uLXR5cGVzY3JpcHQvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImZzL3Byb21pc2VzXCI/YzhjNCIsIndlYnBhY2s6Ly9hY3Rpb24tdHlwZXNjcmlwdC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwicGF0aFwiPzFmMzQiLCJ3ZWJwYWNrOi8vYWN0aW9uLXR5cGVzY3JpcHQvLi9zcmMvaW5kZXgudHM/ZTk0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBfX1dFQlBBQ0tfTkFNRVNQQUNFX09CSkVDVF9fID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7IiwiY29uc3QgX19XRUJQQUNLX05BTUVTUEFDRV9PQkpFQ1RfXyA9IHJlcXVpcmUoXCJmc1wiKTsiLCJjb25zdCBfX1dFQlBBQ0tfTkFNRVNQQUNFX09CSkVDVF9fID0gcmVxdWlyZShcImZzL3Byb21pc2VzXCIpOyIsImNvbnN0IF9fV0VCUEFDS19OQU1FU1BBQ0VfT0JKRUNUX18gPSByZXF1aXJlKFwicGF0aFwiKTsiLCJpbXBvcnQgeyBleGVjU3luYyB9IGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XG5pbXBvcnQgeyByZWFkRmlsZVN5bmMsIHJlYWRkaXJTeW5jLCB3cml0ZUZpbGVTeW5jIH0gZnJvbSBcImZzXCI7XG5pbXBvcnQgeyBhY2Nlc3MsIGNvbnN0YW50cyB9IGZyb20gXCJmcy9wcm9taXNlc1wiO1xuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIjtcbmNvbnN0IFNVTU1BUllfRU5WX1ZBUiA9ICdHSVRIVUJfU1RFUF9TVU1NQVJZJztcbmV4cG9ydCBjb25zdCBqb2JTdW1tYXJ5RmlsZVBhdGggPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcGF0aEZyb21FbnYgPSBwcm9jZXNzLmVudltTVU1NQVJZX0VOVl9WQVJdO1xuICAgIGlmICghcGF0aEZyb21FbnYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBlbnZpcm9ubWVudCB2YXJpYWJsZSBmb3IgJCR7U1VNTUFSWV9FTlZfVkFSfS4gQ2hlY2sgaWYgeW91ciBydW50aW1lIGVudmlyb25tZW50IHN1cHBvcnRzIGpvYiBzdW1tYXJpZXMuYCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGFjY2VzcyhwYXRoRnJvbUVudiwgY29uc3RhbnRzLlJfT0sgfCBjb25zdGFudHMuV19PSyk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gYWNjZXNzIHN1bW1hcnkgZmlsZTogJyR7cGF0aEZyb21FbnZ9Jy4gQ2hlY2sgaWYgdGhlIGZpbGUgaGFzIGNvcnJlY3QgcmVhZC93cml0ZSBwZXJtaXNzaW9ucy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGhGcm9tRW52O1xufTtcbmNvbnN0IHJ1biA9IGFzeW5jICgpID0+IHtcbiAgICBsZXQgam9iU3VtbWFyeSA9ICcnO1xuICAgIGNvbnN0IGZpbGVQYXRoID0gYXdhaXQgam9iU3VtbWFyeUZpbGVQYXRoKCk7XG4gICAgY29uc3QgcGF0aE9iaiA9IHBhdGgucGFyc2UoZmlsZVBhdGgpO1xuICAgIGNvbnN0IGRpciA9IHBhdGhPYmouZGlyO1xuICAgIGNvbnNvbGUubG9nKGBKb2Igc3VtbWFyeSBmaWxlIGRpcmVjdG9yeTogJHtkaXJ9YCk7XG4gICAgY29uc3QgZmlsZXMgPSByZWFkZGlyU3luYyhkaXIpO1xuICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICBjb25zdCBmaWxlT2JqID0gcGF0aC5wYXJzZShmaWxlKTtcbiAgICAgICAgaWYgKGZpbGVPYmouYmFzZS5zdGFydHNXaXRoKCdzdGVwX3N1bW1hcnlfJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBzdGVwIHN1bW1hcnk6ICR7ZmlsZX1gKTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBTdW1tYXJ5ID0gcmVhZEZpbGVTeW5jKGAke2Rpcn0vJHtmaWxlfWAsICd1dGY4Jyk7XG4gICAgICAgICAgICBqb2JTdW1tYXJ5ICs9IHN0ZXBTdW1tYXJ5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGBKb2Igc3VtbWFyeTogJHtqb2JTdW1tYXJ5fWApO1xuICAgIHdyaXRlRmlsZVN5bmMoJ1JFQURNRS5tZCcsIGpvYlN1bW1hcnkpO1xuICAgIHdyaXRlRmlsZVN5bmMoJ2NvbmZpZy5qcycsIGAvLyBBIG1hcmtlZCByZW5kZXJlciBmb3IgbWVybWFpZCBkaWFncmFtc1xyXG4gIGNvbnN0IHJlbmRlcmVyID0ge1xyXG4gICAgICBjb2RlKGNvZGUsIGluZm9zdHJpbmcpIHtcclxuICAgICAgICAgIGlmIChpbmZvc3RyaW5nID09PSAnbWVybWFpZCcpe1xyXG4gICAgICAgICAgICAgIHJldHVybiBcXGA8cHJlIGNsYXNzPVwibWVybWFpZFwiPlxcJFxce2NvZGVcXH08L3ByZT5cXGBcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICB9LFxyXG4gIH07XHJcbiAgXHJcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgIG1hcmtlZF9leHRlbnNpb25zOiBbeyByZW5kZXJlciB9XSxcclxuICAgICAgc2NyaXB0OiBbXHJcbiAgICAgICAgICB7IHVybDogJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbWVybWFpZC9kaXN0L21lcm1haWQubWluLmpzJyB9LCAgXHJcbiAgICAgICAgICAvLyBBbHRlcm5hdGl2ZSB0byBhYm92ZTogaWYgeW91IGhhdmUgbm8gSW50ZXJuZXQgYWNjZXNzLCB5b3UgY2FuIGFsc28gZW1iZWQgYSBsb2NhbCBjb3B5XHJcbiAgICAgICAgICAvLyB7IGNvbnRlbnQ6IHJlcXVpcmUoJ2ZzJykucmVhZEZpbGVTeW5jKCcuL25vZGVfbW9kdWxlcy9tZXJtYWlkL2Rpc3QvbWVybWFpZC5qcycsICd1dGYtOCcpIH1cclxuICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiwgbWVybWFpZCBpbml0aWFsaXplIGRvZXNuJ3QgcmVuZGVyIGRpYWdyYW1zIGFzIGl0IHNob3VsZC4gSXQncyBsaWtlIGl0J3MgbWlzc2luZ1xyXG4gICAgICAgICAgLy8gdGhlIGRvY3VtZW50LnJlYWR5IGNhbGxiYWNrLiBJbnN0ZWFkIHdlIGNhbiBleHBsaWNpdGx5IHJlbmRlciB0aGUgZGlhZ3JhbXNcclxuICAgICAgICAgIHsgY29udGVudDogJ21lcm1haWQuaW5pdGlhbGl6ZSh7IHN0YXJ0T25Mb2FkOiBmYWxzZX0pOyAoYXN5bmMgKCkgPT4geyBhd2FpdCBtZXJtYWlkLnJ1bigpOyB9KSgpOycgfVxyXG4gICAgICBdXHJcbiAgfTtgKTtcbiAgICBleGVjU3luYyhgbnBtIGkgLWcgbWQtdG8tcGRmYCk7XG4gICAgZXhlY1N5bmMoYG1kLXRvLXBkZiAtLWNvbmZpZy1maWxlIC4vY29uZmlnLmpzIC4vUkVBRE1FLm1kYCk7XG4gICAgY29uc29sZS5sb2coJ1BERiBnZW5lcmF0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgcmVhZGRpclN5bmMoJy4nKS5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgICBpZiAoZmlsZS5lbmRzV2l0aCgnLnBkZicpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUERGIGZpbGU6ICR7ZmlsZX1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbnJ1bigpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///905\n")}},__webpack_require__={n:e=>{var c=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(c,{a:c}),c},d:(e,c)=>{for(var n in c)__webpack_require__.o(c,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:c[n]})},o:(e,c)=>Object.prototype.hasOwnProperty.call(e,c)},__webpack_exports__={};__webpack_modules__[905](0,__webpack_exports__,__webpack_require__)})();